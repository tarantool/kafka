diff --git a/src/rdkafka_assignor.c b/src/rdkafka_assignor.c
index 465568c4..124df9de 100644
--- a/src/rdkafka_assignor.c
+++ b/src/rdkafka_assignor.c
@@ -235,7 +235,8 @@ static int rd_kafka_member_subscription_match(
 }
 
 
-static void rd_kafka_assignor_topic_destroy(rd_kafka_assignor_topic_t *at) {
+static void rd_kafka_assignor_topic_destroy(void *rkat) {
+        rd_kafka_assignor_topic_t *at = (rd_kafka_assignor_topic_t *)rkat;
         rd_list_destroy(&at->members);
         rd_free(at);
 }
@@ -267,7 +268,7 @@ rd_kafka_member_subscriptions_map(rd_kafka_cgrp_t *rkcg,
             rd_kafka_metadata_get_internal(metadata);
 
         rd_list_init(eligible_topics, RD_MIN(metadata->topic_cnt, 10),
-                     (void *)rd_kafka_assignor_topic_destroy);
+                     rd_kafka_assignor_topic_destroy);
 
         /* For each topic in the cluster, scan through the member list
          * to find matching subscriptions. */
@@ -451,7 +452,8 @@ rd_kafka_assignor_t *rd_kafka_assignor_find(rd_kafka_t *rk,
 /**
  * Destroys an assignor (but does not unlink).
  */
-static void rd_kafka_assignor_destroy(rd_kafka_assignor_t *rkas) {
+static void rd_kafka_assignor_destroy(void *rkasp) {
+        rd_kafka_assignor_t *rkas = (rd_kafka_assignor_t *) rkasp;
         rd_kafkap_str_destroy(rkas->rkas_protocol_type);
         rd_kafkap_str_destroy(rkas->rkas_protocol_name);
         rd_free(rkas);
@@ -580,7 +582,7 @@ int rd_kafka_assignors_init(rd_kafka_t *rk, char *errstr, size_t errstr_size) {
         int idx = 0;
 
         rd_list_init(&rk->rk_conf.partition_assignors, 3,
-                     (void *)rd_kafka_assignor_destroy);
+                     rd_kafka_assignor_destroy);
 
         /* Initialize builtin assignors (ignore errors) */
         rd_kafka_range_assignor_init(rk);
